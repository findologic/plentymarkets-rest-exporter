#!/usr/bin/env php
<?php

declare(strict_types=1);

use FINDOLOGIC\PlentyMarketsRestExporter\Config;
use FINDOLOGIC\PlentyMarketsRestExporter\Exporter\CsvExporter;
use FINDOLOGIC\PlentyMarketsRestExporter\Exporter\Exporter;
use GuzzleHttp\Client;
use GuzzleHttp\RequestOptions;
use Log4Php\Configurators\LoggerConfigurationAdapterXML;
use Log4Php\Logger;
use Symfony\Component\Yaml\Exception\ParseException;
use Symfony\Component\Yaml\Yaml;

const IMPORT_LOG_PATH = __DIR__ . '/../logs/import.log';

// Empty log before each new import.
if (file_exists(IMPORT_LOG_PATH)) {
    file_put_contents(IMPORT_LOG_PATH, '');
}

require_once __DIR__ . '/../vendor/autoload.php';

$configurationAdapter = new LoggerConfigurationAdapterXML();
$configuration = $configurationAdapter->convert(__DIR__ . '/../config/logger.xml');
$configuration['appenders']['default']['params']['file'] = IMPORT_LOG_PATH;

Logger::configure($configuration);

$internalLogger = Logger::getLogger('import.php');
$customerLogger = Logger::getLogger('import.php');
$configDest = __DIR__ . '/../config/config.yml';

try {
    $rawConfig = Yaml::parseFile($configDest);
} catch (ParseException $e) {
    failExportWithMessage($internalLogger, 'There was an error while parsing the configuration: ' . $e->getMessage());
}

$config = new Config($rawConfig);
if (isset ($argv[1]) && preg_match('/^[A-F0-9]{32}$/', $argv[1])) {
    if (!isset($rawConfig['customerLoginUri']) || empty($rawConfig['customerLoginUri'])) {
        failExportWithMessage(
            $internalLogger,
            'Using a shopkey for exporting only works when there is a customerLoginUri set in the configuration!'
        );
    }

    try {
        $customerLogger->info('Fetching the configuration from the customerlogin, as a shopkey was provided.');
        $response = getCustomerLoginConfiguration($rawConfig['customerLoginUri'], $argv[1]);
        $config = Config::parseByCustomerLoginResponse($response, true);
    } catch (Throwable $e) {
        failExportWithExceptionInformation($internalLogger, $e);
    }
}

/** @var CsvExporter $exporter */
$exporter = Exporter::buildInstance(Exporter::TYPE_CSV, $config, $internalLogger, $customerLogger);
try {
    $exporter->export();
} catch (Throwable $e) {
    failExportWithExceptionInformation($internalLogger, $e);
}

$customerLogger->info(sprintf('The export took %s.', $exporter->getExportTime()));
$customerLogger->info('The export was successful!');

function getCustomerLoginConfiguration(string $customerLoginUri, string $shopkey): array
{
    $client = new Client();
    $response = $client->get($customerLoginUri, [
        RequestOptions::QUERY => ['shopkey' => $shopkey]
    ]);

    return json_decode($response->getBody()->__toString(), true);
}

function failExportWithExceptionInformation(Logger $logger, Throwable $e)
{
    $logger->error($e->getMessage());
    $logger->trace($e->getTraceAsString());
    $logger->error('The export was unsuccessful and failed with an exception.');
    exit(1);
}

function failExportWithMessage(Logger $logger, string $message)
{
    $logger->error($message);
    $logger->error('The export was unsuccessful and failed.');
    exit(1);
}
